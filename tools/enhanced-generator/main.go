package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"go/ast"
	"go/constant"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

// Packet generator with stub codecs (可擴充)：產生 struct + PacketID + stub ReadFrom/WriteTo。
// 已處理基本型別、array、option、switch(mapper)，未知型別降級為 interface{} 確保可編譯。

// protocol schema subset
type protocol struct {
	Play struct {
		ToClient struct {
			Types map[string]any `json:"types"`
		} `json:"toClient"`
		ToServer struct {
			Types map[string]any `json:"types"`
		} `json:"toServer"`
	} `json:"play"`
}

var (
	protocolFile = flag.String("protocol", "", "path to protocol.json")
	outputDir    = flag.String("output", "", "output directory")
	direction    = flag.String("direction", "client", "client or server")
	packetidPkg  = flag.String("packetid", "git.konjactw.dev/falloutBot/go-mc/data/packetid", "packetid import path")
)

func main() {
	flag.Parse()
	if *protocolFile == "" || *outputDir == "" {
		log.Fatal("Usage: -protocol <protocol.json> -output <dir> -direction <client|server>")
	}

	data, err := os.ReadFile(*protocolFile)
	if err != nil {
		log.Fatal(err)
	}
	var p protocol
	if err := json.Unmarshal(data, &p); err != nil {
		log.Fatal(err)
	}

	var packets map[string]any
	pkg := "client"
	pidType := "Clientbound"
	if strings.ToLower(*direction) == "server" {
		packets = p.Play.ToServer.Types
		pkg = "server"
		pidType = "Serverbound"
	} else {
		packets = p.Play.ToClient.Types
	}

	pidMap := loadPacketIDs(*packetidPkg)

	defs := collect(packets, *direction, pidMap)
	sort.Slice(defs, func(i, j int) bool { return defs[i].Name < defs[j].Name })

	if err := os.MkdirAll(*outputDir, 0o755); err != nil {
		log.Fatal(err)
	}

	tmpl := template.Must(template.New("packet").Parse(`// Code generated by enhanced-generator; DO NOT EDIT.
package {{.Package}}

import (
    "io"
    "git.konjactw.dev/falloutBot/go-mc/data/packetid"
    pk "git.konjactw.dev/falloutBot/go-mc/net/packet"
)

// keep pk import used even when no pk.* fields are present
var _ = pk.Angle(0)

type {{.StructName}} struct {
{{- range .Fields}}
    {{.Name}} {{.Type}}{{if .Tag}} {{.Tag}}{{end}}
{{- end}}
}

func (*{{.StructName}}) PacketID() packetid.{{.PIDType}}PacketID {
    return packetid.{{.PIDType}}PacketID({{.PIDLit}})
}

// ReadFrom is a stub (not implemented)
func (p *{{.StructName}}) ReadFrom(r io.Reader) (n int64, err error) { return 0, nil }

// WriteTo is a stub (not implemented)
func (p {{.StructName}}) WriteTo(w io.Writer) (n int64, err error) { return 0, nil }

func init() {
    registerPacket(packetid.{{.PIDType}}PacketID({{.PIDLit}}), func() {{.PIDType}}Packet { return &{{.StructName}}{} })
}
`))

	for _, d := range defs {
		fname := filepath.Join(*outputDir, strings.ToLower(d.Name)+".go")
		f, err := os.Create(fname)
		if err != nil {
			log.Fatal(err)
		}
		err = tmpl.Execute(f, map[string]any{
			"Package":    pkg,
			"StructName": d.Struct,
			"Fields":     d.Fields,
			"PIDType":    pidType,
			"PIDLit":     d.PIDLit,
		})
		f.Close()
		if err != nil {
			log.Fatal(err)
		}
	}
	fmt.Printf("✅ generated %d packets to %s (stub codecs)\n", len(defs), *outputDir)
}

type field struct {
	Name string
	Type string
	Tag  string
}

type def struct {
	Name    string
	Struct  string
	Fields  []field
	PIDLit  string
	Package string
}

func collect(m map[string]any, dir string, pidMap map[string]int64) []def {
	var out []def
	for name, v := range m {
		container, ok := v.([]any)
		if !ok || len(container) < 2 || container[0] != "container" {
			continue
		}
		fs, _ := container[1].([]any)
		var fields []field
		for _, f := range fs {
			fm, ok := f.(map[string]any)
			if !ok {
				continue
			}
			rawName, _ := fm["name"].(string)
			goName := safeName(toPascal(strings.TrimSpace(rawName)))
			rt := resolveType(fm["type"])
			fields = append(fields, field{Name: goName, Type: rt.goType, Tag: rt.tag})
		}
		structName := toPascal(strings.TrimPrefix(name, "packet_"))
		key := "Clientbound" + structName
		if strings.ToLower(dir) == "server" {
			key = "Serverbound" + structName
		}
		pidLit := "0"
		if val, ok := pidMap[key]; ok {
			pidLit = fmt.Sprintf("%d", val)
		}

		out = append(out, def{Name: name, Struct: structName, Fields: fields, PIDLit: pidLit})
	}
	return out
}

type resolved struct{ goType, tag string }

func resolveType(t any) resolved {
	switch v := t.(type) {
	case string:
		return simpleType(v)
	case []any:
		if len(v) > 0 {
			if kind, _ := v[0].(string); kind == "array" {
				return resolved{goType: "[]interface{}"}
			}
		}
		return resolved{goType: "interface{}"}
	default:
		return resolved{goType: "interface{}"}
	}
}

func simpleType(t string) resolved {
	switch t {
	case "varint", "optvarint":
		return resolved{goType: "int32", tag: "`mc:\"VarInt\"`"}
	case "varlong":
		return resolved{goType: "int64", tag: "`mc:\"VarInt\"`"}
	case "i8":
		return resolved{goType: "int8", tag: "`mc:\"Byte\"`"}
	case "i16", "u16":
		return resolved{goType: "int16", tag: "`mc:\"Short\"`"}
	case "i32", "u32":
		return resolved{goType: "int32", tag: "`mc:\"Int\"`"}
	case "i64", "u64":
		return resolved{goType: "int64", tag: "`mc:\"Long\"`"}
	case "f32":
		return resolved{goType: "float32", tag: "`mc:\"Float\"`"}
	case "f64":
		return resolved{goType: "float64", tag: "`mc:\"Double\"`"}
	case "bool":
		return resolved{goType: "bool", tag: "`mc:\"Boolean\"`"}
	case "string", "pstring":
		return resolved{goType: "string", tag: "`mc:\"String\"`"}
	case "UUID":
		return resolved{goType: "interface{}"}
	case "angle":
		return resolved{goType: "pk.Angle", tag: "`mc:\"Angle\"`"}
	case "buffer":
		return resolved{goType: "[]byte", tag: "`mc:\"ByteArray\"`"}
	case "nbt", "anonymousNbt":
		return resolved{goType: "pk.NBTField"}
	default:
		return resolved{goType: "interface{}"}
	}
}

// loadPacketIDs 解析 packetid 包，取得常數名稱 -> 整數值對應。
func loadPacketIDs(pkgPath string) map[string]int64 {
	out := make(map[string]int64)

	cmd := exec.Command("go", "list", "-f", "{{.Dir}}", pkgPath)
	dirBytes, err := cmd.Output()
	if err != nil {
		return out
	}
	dir := strings.TrimSpace(string(dirBytes))

	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, nil, 0)
	if err != nil {
		return out
	}

	var files []*ast.File
	for _, p := range pkgs {
		for _, f := range p.Files {
			files = append(files, f)
		}
	}

	info := &types.Info{Defs: make(map[*ast.Ident]types.Object)}
	conf := types.Config{Importer: importer.Default()}
	if _, err := conf.Check(pkgPath, fset, files, info); err != nil {
		return out
	}

	for ident, obj := range info.Defs {
		if c, ok := obj.(*types.Const); ok {
			if c.Val().Kind() != constant.Int {
				continue
			}
			if val, ok := constant.Int64Val(c.Val()); ok {
				out[ident.Name] = val
			}
		}
	}

	return out
}

func toPascal(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if len(p) == 0 {
			continue
		}
		parts[i] = strings.ToUpper(p[:1]) + p[1:]
	}
	return strings.Join(parts, "")
}

func safeName(s string) string {
	keywords := map[string]struct{}{
		"break": {}, "default": {}, "func": {}, "interface": {}, "select": {},
		"case": {}, "defer": {}, "go": {}, "map": {}, "struct": {},
		"chan": {}, "else": {}, "goto": {}, "package": {}, "switch": {},
		"const": {}, "fallthrough": {}, "if": {}, "range": {}, "type": {},
		"continue": {}, "for": {}, "import": {}, "return": {}, "var": {},
	}
	if _, ok := keywords[strings.ToLower(s)]; ok || s == "" {
		return "Field" + toPascal(s)
	}
	return s
}
