// Code generated by enhanced-generator v2 from protocol.json; DO NOT EDIT manually.
// To regenerate: go run main_v2.go -protocol <path> -output <dir> -direction client

package client

import (
	"fmt"
	pk "git.konjactw.dev/falloutBot/go-mc/net/packet"
	"git.konjactw.dev/patyhank/minego/pkg/protocol/packetid"
	"io"
)

// RecipeBookAddEntriesEntryRecipeDisplay is a sub-structure used in the packet.
type RecipeBookAddEntriesEntryRecipeDisplay struct {
	// Mapper to string
	Type string
	// Switch 基於 Type：
	//   crafting_shapeless -> [container [map[name:ingredients type:[array map[countType:varint type:SlotDisplay]]] map[name:result type:SlotDisplay] map[name:craftingStation type:SlotDisplay]]]
	//   crafting_shaped -> [container [map[name:width type:varint] map[name:height type:varint] map[name:ingredients type:[array map[countType:varint type:SlotDisplay]]] map[name:result type:SlotDisplay] map[name:craftingStation type:SlotDisplay]]]
	//   furnace -> [container [map[name:ingredient type:SlotDisplay] map[name:fuel type:SlotDisplay] map[name:result type:SlotDisplay] map[name:craftingStation type:SlotDisplay] map[name:duration type:varint] map[name:experience type:f32]]]
	//   stonecutter -> [container [map[name:ingredient type:SlotDisplay] map[name:result type:SlotDisplay] map[name:craftingStation type:SlotDisplay]]]
	//   smithing -> [container [map[name:template type:SlotDisplay] map[name:base type:SlotDisplay] map[name:addition type:SlotDisplay] map[name:result type:SlotDisplay] map[name:craftingStation type:SlotDisplay]]]

	Data interface{}
}

// ReadFrom reads the data from the reader.
func (p *RecipeBookAddEntriesEntryRecipeDisplay) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	var mapperVal pk.VarInt
	temp, err = mapperVal.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	switch mapperVal {
	case 0:
		p.Type = "crafting_shapeless"
	case 1:
		p.Type = "crafting_shaped"
	case 2:
		p.Type = "furnace"
	case 3:
		p.Type = "stonecutter"
	case 4:
		p.Type = "smithing"
	default:
		return n, fmt.Errorf("unknown mapper value %d for Type", mapperVal)
	}

	switch p.Type {
	default:
		// 無對應負載
	}

	return n, nil
}

// WriteTo writes the data to the writer.
func (p RecipeBookAddEntriesEntryRecipeDisplay) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	switch p.Type {
	case "crafting_shapeless":
		temp, err = pk.VarInt(0).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "crafting_shaped":
		temp, err = pk.VarInt(1).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "furnace":
		temp, err = pk.VarInt(2).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "stonecutter":
		temp, err = pk.VarInt(3).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "smithing":
		temp, err = pk.VarInt(4).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	default:
		return n, fmt.Errorf("unknown Type value %v", p.Type)
	}

	switch v := p.Data.(type) {
	default:
		return n, fmt.Errorf("unsupported switch type for Data: %T", v)
	}

	return n, nil
}

// RecipeBookAddEntriesEntryRecipe is a sub-structure used in the packet.
type RecipeBookAddEntriesEntryRecipe struct {
	DisplayId int32 `mc:"VarInt"`
	Display   RecipeBookAddEntriesEntryRecipeDisplay
	Group     int32 `mc:"VarInt"`
	// Mapper to string
	Category string
	// TODO: Optional complex type
	CraftingRequirements *interface{}
}

// ReadFrom reads the data from the reader.
func (p *RecipeBookAddEntriesEntryRecipe) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	var displayId pk.VarInt
	temp, err = displayId.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.DisplayId = int32(displayId)

	temp, err = p.Display.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}

	var group pk.VarInt
	temp, err = group.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.Group = int32(group)

	var mapperVal pk.VarInt
	temp, err = mapperVal.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	switch mapperVal {
	case 0:
		p.Category = "crafting_building_blocks"
	case 3:
		p.Category = "crafting_misc"
	case 6:
		p.Category = "furnace_misc"
	case 7:
		p.Category = "blast_furnace_blocks"
	case 9:
		p.Category = "smoker_food"
	case 11:
		p.Category = "smithing"
	case 12:
		p.Category = "campfire"
	case 1:
		p.Category = "crafting_redstone"
	case 2:
		p.Category = "crafting_equipment"
	case 4:
		p.Category = "furnace_food"
	case 5:
		p.Category = "furnace_blocks"
	case 8:
		p.Category = "blast_furnace_misc"
	case 10:
		p.Category = "stonecutter"
	default:
		return n, fmt.Errorf("unknown mapper value %d for Category", mapperVal)
	}

	// TODO: Read optional complex type

	return n, nil
}

// WriteTo writes the data to the writer.
func (p RecipeBookAddEntriesEntryRecipe) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	temp, err = pk.VarInt(p.DisplayId).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = p.Display.WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.VarInt(p.Group).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	switch p.Category {
	case "crafting_building_blocks":
		temp, err = pk.VarInt(0).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "crafting_misc":
		temp, err = pk.VarInt(3).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "furnace_misc":
		temp, err = pk.VarInt(6).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "blast_furnace_blocks":
		temp, err = pk.VarInt(7).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "smoker_food":
		temp, err = pk.VarInt(9).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "smithing":
		temp, err = pk.VarInt(11).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "campfire":
		temp, err = pk.VarInt(12).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "crafting_redstone":
		temp, err = pk.VarInt(1).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "crafting_equipment":
		temp, err = pk.VarInt(2).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "furnace_food":
		temp, err = pk.VarInt(4).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "furnace_blocks":
		temp, err = pk.VarInt(5).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "blast_furnace_misc":
		temp, err = pk.VarInt(8).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "stonecutter":
		temp, err = pk.VarInt(10).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	default:
		return n, fmt.Errorf("unknown Category value %v", p.Category)
	}

	// TODO: Write optional complex type

	return n, nil
}

// RecipeBookAddEntriesEntry is a sub-structure used in the packet.
type RecipeBookAddEntriesEntry struct {
	Recipe RecipeBookAddEntriesEntryRecipe
	// Bitflags
	Flags uint8
}

// ReadFrom reads the data from the reader.
func (p *RecipeBookAddEntriesEntry) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	temp, err = p.Recipe.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}

	var flags pk.UnsignedByte
	temp, err = flags.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.Flags = uint8(flags)

	return n, nil
}

// WriteTo writes the data to the writer.
func (p RecipeBookAddEntriesEntry) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	temp, err = p.Recipe.WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.UnsignedByte(p.Flags).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	return n, nil
}

// RecipeBookAdd represents the Clientbound RecipeBookAdd packet.

type RecipeBookAdd struct {
	Entries []RecipeBookAddEntriesEntry
	Replace bool
}

// PacketID returns the packet ID for this packet.
func (*RecipeBookAdd) PacketID() packetid.ClientboundPacketID {
	return packetid.ClientboundRecipeBookAdd
}

// ReadFrom reads the packet data from the reader.
func (p *RecipeBookAdd) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	var entriesCount pk.VarInt
	temp, err = entriesCount.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.Entries = make([]RecipeBookAddEntriesEntry, entriesCount)
	for i := 0; i < int(entriesCount); i++ {
		temp, err = p.Entries[i].ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
	}

	var replace pk.Boolean
	temp, err = replace.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.Replace = bool(replace)

	return n, nil
}

// WriteTo writes the packet data to the writer.
func (p RecipeBookAdd) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	temp, err = pk.VarInt(len(p.Entries)).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}
	for i := range p.Entries {
		temp, err = p.Entries[i].WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	}

	temp, err = pk.Boolean(p.Replace).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	return n, nil
}

func init() {
	registerPacket(packetid.ClientboundRecipeBookAdd, func() ClientboundPacket {
		return &RecipeBookAdd{}
	})
}
