// Code generated by enhanced-generator v2 from protocol.json; DO NOT EDIT manually.
// To regenerate: go run main_v2.go -protocol <path> -output <dir> -direction client

package client

import (
	"fmt"
	pk "git.konjactw.dev/falloutBot/go-mc/net/packet"
	"git.konjactw.dev/patyhank/minego/pkg/protocol/packetid"
	"git.konjactw.dev/patyhank/minego/pkg/protocol/slot"
	"io"
)

// SetSlotItemTemp is a sub-structure used in the packet.
type SetSlotItemTemp struct {
	// Mapper to string
	Type string
	// Switch 基於 Type：
	//   shulker/color -> varint
	//   lore -> [array map[countType:varint type:anonymousNbt]]
	//   enchantment_glint_override -> bool
	//   charged_projectiles -> [container [map[name:projectiles type:[array map[countType:varint type:Slot]]]]]
	//   debug_stick_state -> anonymousNbt
	//   fox/variant -> varint
	//   tropical_fish/pattern_color -> varint
	//   item_name -> anonymousNbt
	//   intangible_projectile -> void
	//   tool -> [container [map[name:rules type:[array map[countType:varint type:[container [map[name:blocks type:IDSet] map[name:speed type:[option f32]] map[name:correctDropForBlocks type:[option bool]]]]]]] map[name:defaultMiningSpeed type:f32] map[name:damagePerBlock type:varint] map[name:canDestroyBlocksInCreative type:bool]]]
	//   written_book_content -> [container [map[name:rawTitle type:string] map[name:filteredTitle type:[option string]] map[name:author type:string] map[name:generation type:varint] map[name:pages type:[array map[countType:varint type:ItemWrittenBookPage]]] map[name:resolved type:bool]]]
	//   bucket_entity_data -> anonymousNbt
	//   ominous_bottle_amplifier -> varint
	//   banner_patterns -> [container [map[name:layers type:[array map[countType:varint type:BannerPatternLayer]]]]]
	//   break_sound -> ItemSoundHolder
	//   custom_data -> anonymousNbt
	//   dyed_color -> i32
	//   map_color -> i32
	//   trim -> [container [map[name:material type:[registryEntryHolder map[baseName:materialId otherwise:map[name:data type:ArmorTrimMaterial]]]] map[name:pattern type:[registryEntryHolder map[baseName:patternId otherwise:map[name:data type:ArmorTrimPattern]]]]]]
	//   lock -> anonymousNbt
	//   tooltip_display -> [container [map[name:hideTooltip type:bool] map[name:hiddenComponents type:[array map[countType:varint type:varint]]]]]
	//   repair_cost -> varint
	//   tooltip_style -> string
	//   instrument -> [container [map[name:hasHolder type:bool] map[name:data type:[switch map[compareTo:hasHolder fields:map[false:string true:[registryEntryHolder map[baseName:instrumentId otherwise:map[name:data type:InstrumentData]]]]]]]]]
	//   custom_model_data -> [container [map[name:floats type:[array map[countType:varint type:f32]]] map[name:flags type:[array map[countType:varint type:bool]]] map[name:strings type:[array map[countType:varint type:string]]] map[name:colors type:[array map[countType:varint type:i32]]]]]
	//   equippable -> [container [map[name:slot type:[mapper map[mappings:map[0:main_hand 1:off_hand 2:feet 3:legs 4:chest 5:head 6:body 7:saddle] type:varint]]] map[name:sound type:ItemSoundHolder] map[name:model type:[option string]] map[name:cameraOverlay type:[option string]] map[name:allowedEntities type:[option IDSet]] map[name:dispensable type:bool] map[name:swappable type:bool] map[name:damageable type:bool] map[name:equipOnInteract type:bool] map[name:shearable type:bool] map[name:shearingSound type:ItemSoundHolder]]]
	//   weapon -> [container [map[name:itemDamagePerAttack type:varint] map[name:disableBlockingForSeconds type:f32]]]
	//   map_decorations -> anonymousNbt
	//   writable_book_content -> [container [map[name:pages type:[array map[countType:varint type:ItemBookPage]]]]]
	//   villager/variant -> varint
	//   tropical_fish/pattern -> varint
	//   rabbit/variant -> varint
	//   chicken/variant -> [registryEntryHolder map[baseName:variantId otherwise:map[name:variantData type:string]]]
	//   blocks_attacks -> [container [map[name:blockDelaySeconds type:f32] map[name:disableCooldownScale type:f32] map[name:damageReductions type:[array map[countType:varint type:[container [map[name:horizontalBlockingAngle type:f32] map[name:type type:[option IDSet]] map[name:base type:f32] map[name:factor type:f32]]]]]] map[name:itemDamage type:[container [map[name:threshold type:f32] map[name:base type:f32] map[name:factor type:f32]]]] map[name:bypassedBy type:[option string]] map[name:blockSound type:[option ItemSoundHolder]] map[name:disableSound type:[option ItemSoundHolder]]]]
	//   potion_duration_scale -> f32
	//   bundle_contents -> [container [map[name:contents type:[array map[countType:varint type:Slot]]]]]
	//   provides_trim_material -> [container [map[name:hasHolder type:bool] map[name:material type:[switch map[compareTo:hasHolder fields:map[false:string true:[registryEntryHolder map[baseName:materialId otherwise:map[name:data type:ArmorTrimMaterial]]]]]]]]]
	//   wolf/collar -> varint
	//   pig/variant -> varint
	//   cow/variant -> varint
	//   frog/variant -> varint
	//   damage_resistant -> string
	//   max_stack_size -> varint
	//   item_model -> string
	//   enchantments -> [container [map[name:enchantments type:[array map[countType:varint type:[container [map[name:id type:varint] map[name:level type:varint]]]]]]]]
	//   stored_enchantments -> [container [map[name:enchantments type:[array map[countType:varint type:[container [map[name:id type:varint] map[name:level type:varint]]]]]]]]
	//   creative_slot_lock -> void
	//   use_cooldown -> [container [map[name:seconds type:f32] map[name:cooldownGroup type:[option string]]]]
	//   map_id -> varint
	//   rarity -> [mapper map[mappings:map[0:common 1:uncommon 2:rare 3:epic] type:varint]]
	//   food -> [container [map[name:nutrition type:varint] map[name:saturationModifier type:f32] map[name:canAlwaysEat type:bool]]]
	//   enchantable -> varint
	//   jukebox_playable -> [container [map[name:hasHolder type:bool] map[name:song type:[switch map[compareTo:hasHolder fields:map[false:string true:[registryEntryHolder map[baseName:songId otherwise:map[name:data type:JukeboxSongData]]]]]]]]]
	//   note_block_sound -> string
	//   base_color -> varint
	//   container -> [container [map[name:contents type:[array map[countType:varint type:Slot]]]]]
	//   wolf/variant -> varint
	//   unbreakable -> void
	//   potion_contents -> [container [map[name:potionId type:[option varint]] map[name:customColor type:[option i32]] map[name:customEffects type:[array map[countType:varint type:ItemPotionEffect]]] map[name:customName type:[option string]]]]
	//   provides_banner_patterns -> string
	//   mooshroom/variant -> varint
	//   sheep/color -> varint
	//   max_damage -> varint
	//   damage -> varint
	//   attribute_modifiers -> [container [map[name:attributes type:[array map[countType:varint type:[container [map[name:typeId type:varint] map[name:name type:string] map[name:value type:f64] map[name:operation type:[mapper map[mappings:map[0:add 1:multiply_base 2:multiply_total] type:varint]]] map[name:slot type:[mapper map[mappings:map[0:any 1:main_hand 10:saddle 2:off_hand 3:hand 4:feet 5:legs 6:chest 7:head 8:armor 9:body] type:varint]]]]]]]] map[name:display type:[container [map[name:type type:[mapper map[mappings:map[0:default 1:hidden 2:override] type:varint]]] map[name:component type:[switch map[compareTo:type fields:map[override:anonymousNbt]]]]]]]]]
	//   glider -> void
	//   block_entity_data -> anonymousNbt
	//   lodestone_tracker -> [container [map[name:globalPosition type:[option [container [map[name:dimension type:string] map[name:position type:position]]]]] map[name:tracked type:bool]]]
	//   fireworks -> [container [map[name:flightDuration type:varint] map[name:explosions type:[array map[countType:varint type:ItemFireworkExplosion]]]]]
	//   parrot/variant -> varint
	//   death_protection -> [container [map[name:effects type:[array map[countType:varint type:ItemConsumeEffect]]]]]
	//   pot_decorations -> [container [map[name:decorations type:[array map[countType:varint type:varint]]]]]
	//   horse/variant -> varint
	//   axolotl/variant -> varint
	//   cat/variant -> varint
	//   custom_name -> anonymousNbt
	//   can_place_on -> [container [map[name:predicates type:[array map[countType:varint type:ItemBlockPredicate]]]]]
	//   use_remainder -> Slot
	//   wolf/sound_variant -> varint
	//   tropical_fish/base_color -> varint
	//   painting/variant -> [registryEntryHolder map[baseName:variantId otherwise:map[name:data type:EntityMetadataPaintingVariant]]]
	//   llama/variant -> varint
	//   consumable -> [container [map[name:consume_seconds type:f32] map[name:animation type:[mapper map[mappings:map[0:none 1:eat 10:bundle 2:drink 3:block 4:bow 5:spear 6:crossbow 7:spyglass 8:toot_horn 9:brush] type:varint]]] map[name:sound type:ItemSoundHolder] map[name:makes_particles type:bool] map[name:effects type:[array map[countType:varint type:ItemConsumeEffect]]]]]
	//   repairable -> [container [map[name:items type:IDSet]]]
	//   map_post_processing -> varint
	//   entity_data -> anonymousNbt
	//   firework_explosion -> ItemFireworkExplosion
	//   bees -> [container [map[name:bees type:[array map[countType:varint type:[container [map[name:nbtData type:anonymousNbt] map[name:ticksInHive type:varint] map[name:minTicksInHive type:varint]]]]]]]]
	//   can_break -> [container [map[name:predicates type:[array map[countType:varint type:ItemBlockPredicate]]]]]
	//   profile -> [container [map[name:name type:[option string]] map[name:uuid type:[option UUID]] map[name:properties type:[array map[countType:varint type:[container [map[name:name type:string] map[name:value type:string] map[name:signature type:[option string]]]]]]]]]
	//   block_state -> [container [map[name:properties type:[array map[countType:varint type:[container [map[name:name type:string] map[name:value type:string]]]]]]]]
	//   container_loot -> anonymousNbt
	//   suspicious_stew_effects -> [container [map[name:effects type:[array map[countType:varint type:[container [map[name:effect type:varint] map[name:duration type:varint]]]]]]]]
	//   recipes -> anonymousNbt
	//   salmon/size -> varint
	//   cat/collar -> varint

	Data interface{}
}

// ReadFrom reads the data from the reader.
func (p *SetSlotItemTemp) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	var mapperVal pk.VarInt
	temp, err = mapperVal.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	switch mapperVal {
	case 18:
		p.Type = "enchantment_glint_override"
	case 48:
		p.Type = "debug_stick_state"
	case 69:
		p.Type = "lock"
	case 77:
		p.Type = "salmon/size"
	case 79:
		p.Type = "tropical_fish/pattern"
	case 81:
		p.Type = "tropical_fish/pattern_color"
	case 89:
		p.Type = "painting/variant"
	case 11:
		p.Type = "can_place_on"
	case 31:
		p.Type = "tooltip_style"
	case 50:
		p.Type = "bucket_entity_data"
	case 53:
		p.Type = "provides_trim_material"
	case 57:
		p.Type = "recipes"
	case 17:
		p.Type = "creative_slot_lock"
	case 27:
		p.Type = "enchantable"
	case 39:
		p.Type = "map_post_processing"
	case 49:
		p.Type = "entity_data"
	case 60:
		p.Type = "fireworks"
	case 82:
		p.Type = "mooshroom/variant"
	case 8:
		p.Type = "lore"
	case 40:
		p.Type = "potion_duration_scale"
	case 73:
		p.Type = "wolf/variant"
	case 85:
		p.Type = "cow/variant"
	case 28:
		p.Type = "equippable"
	case 64:
		p.Type = "base_color"
	case 71:
		p.Type = "break_sound"
	case 90:
		p.Type = "llama/variant"
	case 0:
		p.Type = "custom_data"
	case 3:
		p.Type = "damage"
	case 24:
		p.Type = "damage_resistant"
	case 26:
		p.Type = "weapon"
	case 34:
		p.Type = "stored_enchantments"
	case 38:
		p.Type = "map_decorations"
	case 41:
		p.Type = "charged_projectiles"
	case 58:
		p.Type = "lodestone_tracker"
	case 6:
		p.Type = "item_name"
	case 12:
		p.Type = "can_break"
	case 19:
		p.Type = "intangible_projectile"
	case 25:
		p.Type = "tool"
	case 35:
		p.Type = "dyed_color"
	case 47:
		p.Type = "trim"
	case 56:
		p.Type = "provides_banner_patterns"
	case 76:
		p.Type = "fox/variant"
	case 5:
		p.Type = "custom_name"
	case 7:
		p.Type = "item_model"
	case 15:
		p.Type = "tooltip_display"
	case 37:
		p.Type = "map_id"
	case 52:
		p.Type = "instrument"
	case 66:
		p.Type = "container"
	case 72:
		p.Type = "villager/variant"
	case 86:
		p.Type = "chicken/variant"
	case 23:
		p.Type = "use_cooldown"
	case 46:
		p.Type = "written_book_content"
	case 51:
		p.Type = "block_entity_data"
	case 54:
		p.Type = "ominous_bottle_amplifier"
	case 59:
		p.Type = "firework_explosion"
	case 61:
		p.Type = "profile"
	case 75:
		p.Type = "wolf/collar"
	case 78:
		p.Type = "parrot/variant"
	case 30:
		p.Type = "glider"
	case 32:
		p.Type = "death_protection"
	case 55:
		p.Type = "jukebox_playable"
	case 67:
		p.Type = "block_state"
	case 80:
		p.Type = "tropical_fish/base_color"
	case 87:
		p.Type = "frog/variant"
	case 91:
		p.Type = "axolotl/variant"
	case 93:
		p.Type = "cat/collar"
	case 13:
		p.Type = "attribute_modifiers"
	case 33:
		p.Type = "blocks_attacks"
	case 68:
		p.Type = "bees"
	case 74:
		p.Type = "wolf/sound_variant"
	case 84:
		p.Type = "pig/variant"
	case 88:
		p.Type = "horse/variant"
	case 94:
		p.Type = "sheep/color"
	case 2:
		p.Type = "max_damage"
	case 14:
		p.Type = "custom_model_data"
	case 42:
		p.Type = "bundle_contents"
	case 62:
		p.Type = "note_block_sound"
	case 70:
		p.Type = "container_loot"
	case 95:
		p.Type = "shulker/color"
	case 4:
		p.Type = "unbreakable"
	case 20:
		p.Type = "food"
	case 22:
		p.Type = "use_remainder"
	case 29:
		p.Type = "repairable"
	case 36:
		p.Type = "map_color"
	case 43:
		p.Type = "potion_contents"
	case 45:
		p.Type = "writable_book_content"
	case 9:
		p.Type = "rarity"
	case 16:
		p.Type = "repair_cost"
	case 21:
		p.Type = "consumable"
	case 63:
		p.Type = "banner_patterns"
	case 65:
		p.Type = "pot_decorations"
	case 83:
		p.Type = "rabbit/variant"
	case 92:
		p.Type = "cat/variant"
	case 1:
		p.Type = "max_stack_size"
	case 10:
		p.Type = "enchantments"
	case 44:
		p.Type = "suspicious_stew_effects"
	default:
		return n, fmt.Errorf("unknown mapper value %d for Type", mapperVal)
	}

	switch p.Type {
	case "pig/variant":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "cow/variant":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "frog/variant":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "damage_resistant":
		var val string
		var elem pk.String
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = string(elem)
		p.Data = val
	case "max_stack_size":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "item_model":
		var val string
		var elem pk.String
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = string(elem)
		p.Data = val
	case "creative_slot_lock":
		var val struct{}
		p.Data = val
	case "map_id":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "enchantable":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "note_block_sound":
		var val string
		var elem pk.String
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = string(elem)
		p.Data = val
	case "base_color":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "wolf/variant":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "unbreakable":
		var val struct{}
		p.Data = val
	case "provides_banner_patterns":
		var val string
		var elem pk.String
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = string(elem)
		p.Data = val
	case "mooshroom/variant":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "sheep/color":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "max_damage":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "damage":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "glider":
		var val struct{}
		p.Data = val
	case "block_entity_data":
		var val pk.NBTField
		temp, err = (*pk.NBTField)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "parrot/variant":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "horse/variant":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "axolotl/variant":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "cat/variant":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "custom_name":
		var val pk.NBTField
		temp, err = (*pk.NBTField)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "use_remainder":
		var val slot.Slot
		temp, err = (*slot.Slot)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "wolf/sound_variant":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "tropical_fish/base_color":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "llama/variant":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "map_post_processing":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "entity_data":
		var val pk.NBTField
		temp, err = (*pk.NBTField)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "firework_explosion":
		var val pk.NBTField
		temp, err = (*pk.NBTField)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "container_loot":
		var val pk.NBTField
		temp, err = (*pk.NBTField)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "recipes":
		var val pk.NBTField
		temp, err = (*pk.NBTField)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "salmon/size":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "cat/collar":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "shulker/color":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "enchantment_glint_override":
		var val bool
		var elem pk.Boolean
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = bool(elem)
		p.Data = val
	case "debug_stick_state":
		var val pk.NBTField
		temp, err = (*pk.NBTField)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "fox/variant":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "tropical_fish/pattern_color":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "item_name":
		var val pk.NBTField
		temp, err = (*pk.NBTField)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "intangible_projectile":
		var val struct{}
		p.Data = val
	case "bucket_entity_data":
		var val pk.NBTField
		temp, err = (*pk.NBTField)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "ominous_bottle_amplifier":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "break_sound":
		var val pk.NBTField
		temp, err = (*pk.NBTField)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "custom_data":
		var val pk.NBTField
		temp, err = (*pk.NBTField)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "dyed_color":
		var val int32
		temp, err = (*pk.Int)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "map_color":
		var val int32
		temp, err = (*pk.Int)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "lock":
		var val pk.NBTField
		temp, err = (*pk.NBTField)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "repair_cost":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "tooltip_style":
		var val string
		var elem pk.String
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = string(elem)
		p.Data = val
	case "map_decorations":
		var val pk.NBTField
		temp, err = (*pk.NBTField)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "villager/variant":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "tropical_fish/pattern":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "rabbit/variant":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	case "potion_duration_scale":
		var val float32
		temp, err = (*pk.Float)(&val).ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Data = val
	case "wolf/collar":
		var val int32
		var elem pk.VarInt
		temp, err = elem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		val = int32(elem)
		p.Data = val
	default:
		// 無對應負載
	}

	return n, nil
}

// WriteTo writes the data to the writer.
func (p SetSlotItemTemp) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	switch p.Type {
	case "enchantment_glint_override":
		temp, err = pk.VarInt(18).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "debug_stick_state":
		temp, err = pk.VarInt(48).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "lock":
		temp, err = pk.VarInt(69).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "salmon/size":
		temp, err = pk.VarInt(77).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "tropical_fish/pattern":
		temp, err = pk.VarInt(79).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "tropical_fish/pattern_color":
		temp, err = pk.VarInt(81).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "painting/variant":
		temp, err = pk.VarInt(89).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "can_place_on":
		temp, err = pk.VarInt(11).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "tooltip_style":
		temp, err = pk.VarInt(31).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "bucket_entity_data":
		temp, err = pk.VarInt(50).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "provides_trim_material":
		temp, err = pk.VarInt(53).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "recipes":
		temp, err = pk.VarInt(57).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "creative_slot_lock":
		temp, err = pk.VarInt(17).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "enchantable":
		temp, err = pk.VarInt(27).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "map_post_processing":
		temp, err = pk.VarInt(39).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "entity_data":
		temp, err = pk.VarInt(49).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "fireworks":
		temp, err = pk.VarInt(60).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "mooshroom/variant":
		temp, err = pk.VarInt(82).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "lore":
		temp, err = pk.VarInt(8).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "potion_duration_scale":
		temp, err = pk.VarInt(40).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "wolf/variant":
		temp, err = pk.VarInt(73).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "cow/variant":
		temp, err = pk.VarInt(85).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "equippable":
		temp, err = pk.VarInt(28).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "base_color":
		temp, err = pk.VarInt(64).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "break_sound":
		temp, err = pk.VarInt(71).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "llama/variant":
		temp, err = pk.VarInt(90).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "custom_data":
		temp, err = pk.VarInt(0).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "damage":
		temp, err = pk.VarInt(3).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "damage_resistant":
		temp, err = pk.VarInt(24).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "weapon":
		temp, err = pk.VarInt(26).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "stored_enchantments":
		temp, err = pk.VarInt(34).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "map_decorations":
		temp, err = pk.VarInt(38).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "charged_projectiles":
		temp, err = pk.VarInt(41).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "lodestone_tracker":
		temp, err = pk.VarInt(58).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "item_name":
		temp, err = pk.VarInt(6).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "can_break":
		temp, err = pk.VarInt(12).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "intangible_projectile":
		temp, err = pk.VarInt(19).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "tool":
		temp, err = pk.VarInt(25).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "dyed_color":
		temp, err = pk.VarInt(35).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "trim":
		temp, err = pk.VarInt(47).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "provides_banner_patterns":
		temp, err = pk.VarInt(56).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "fox/variant":
		temp, err = pk.VarInt(76).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "custom_name":
		temp, err = pk.VarInt(5).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "item_model":
		temp, err = pk.VarInt(7).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "tooltip_display":
		temp, err = pk.VarInt(15).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "map_id":
		temp, err = pk.VarInt(37).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "instrument":
		temp, err = pk.VarInt(52).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "container":
		temp, err = pk.VarInt(66).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "villager/variant":
		temp, err = pk.VarInt(72).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "chicken/variant":
		temp, err = pk.VarInt(86).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "use_cooldown":
		temp, err = pk.VarInt(23).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "written_book_content":
		temp, err = pk.VarInt(46).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "block_entity_data":
		temp, err = pk.VarInt(51).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "ominous_bottle_amplifier":
		temp, err = pk.VarInt(54).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "firework_explosion":
		temp, err = pk.VarInt(59).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "profile":
		temp, err = pk.VarInt(61).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "wolf/collar":
		temp, err = pk.VarInt(75).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "parrot/variant":
		temp, err = pk.VarInt(78).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "glider":
		temp, err = pk.VarInt(30).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "death_protection":
		temp, err = pk.VarInt(32).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "jukebox_playable":
		temp, err = pk.VarInt(55).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "block_state":
		temp, err = pk.VarInt(67).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "tropical_fish/base_color":
		temp, err = pk.VarInt(80).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "frog/variant":
		temp, err = pk.VarInt(87).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "axolotl/variant":
		temp, err = pk.VarInt(91).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "cat/collar":
		temp, err = pk.VarInt(93).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "attribute_modifiers":
		temp, err = pk.VarInt(13).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "blocks_attacks":
		temp, err = pk.VarInt(33).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "bees":
		temp, err = pk.VarInt(68).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "wolf/sound_variant":
		temp, err = pk.VarInt(74).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "pig/variant":
		temp, err = pk.VarInt(84).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "horse/variant":
		temp, err = pk.VarInt(88).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "sheep/color":
		temp, err = pk.VarInt(94).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "max_damage":
		temp, err = pk.VarInt(2).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "custom_model_data":
		temp, err = pk.VarInt(14).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "bundle_contents":
		temp, err = pk.VarInt(42).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "note_block_sound":
		temp, err = pk.VarInt(62).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "container_loot":
		temp, err = pk.VarInt(70).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "shulker/color":
		temp, err = pk.VarInt(95).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "unbreakable":
		temp, err = pk.VarInt(4).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "food":
		temp, err = pk.VarInt(20).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "use_remainder":
		temp, err = pk.VarInt(22).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "repairable":
		temp, err = pk.VarInt(29).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "map_color":
		temp, err = pk.VarInt(36).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "potion_contents":
		temp, err = pk.VarInt(43).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "writable_book_content":
		temp, err = pk.VarInt(45).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "rarity":
		temp, err = pk.VarInt(9).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "repair_cost":
		temp, err = pk.VarInt(16).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "consumable":
		temp, err = pk.VarInt(21).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "banner_patterns":
		temp, err = pk.VarInt(63).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "pot_decorations":
		temp, err = pk.VarInt(65).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "rabbit/variant":
		temp, err = pk.VarInt(83).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "cat/variant":
		temp, err = pk.VarInt(92).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "max_stack_size":
		temp, err = pk.VarInt(1).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "enchantments":
		temp, err = pk.VarInt(10).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "suspicious_stew_effects":
		temp, err = pk.VarInt(44).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	default:
		return n, fmt.Errorf("unknown Type value %v", p.Type)
	}

	switch v := p.Data.(type) {
	case pk.NBTField:
		temp, err = pk.NBTField(v).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case slot.Slot:
		temp, err = (v).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case int32:
		temp, err = pk.VarInt(v).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case bool:
		temp, err = pk.Boolean(v).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case struct{}:
		if err != nil {
			return n, err
		}
	case string:
		temp, err = pk.String(v).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case float32:
		temp, err = pk.Float(v).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	default:
		return n, fmt.Errorf("unsupported switch type for Data: %T", v)
	}

	return n, nil
}

// SetSlotItemRemoveComponentsEntry is a sub-structure used in the packet.
type SetSlotItemRemoveComponentsEntry struct {
	// Mapper to string
	Type string
}

// ReadFrom reads the data from the reader.
func (p *SetSlotItemRemoveComponentsEntry) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	var mapperVal pk.VarInt
	temp, err = mapperVal.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	switch mapperVal {
	case 56:
		p.Type = "provides_banner_patterns"
	case 76:
		p.Type = "fox/variant"
	case 5:
		p.Type = "custom_name"
	case 7:
		p.Type = "item_model"
	case 15:
		p.Type = "tooltip_display"
	case 37:
		p.Type = "map_id"
	case 52:
		p.Type = "instrument"
	case 66:
		p.Type = "container"
	case 72:
		p.Type = "villager/variant"
	case 86:
		p.Type = "chicken/variant"
	case 23:
		p.Type = "use_cooldown"
	case 46:
		p.Type = "written_book_content"
	case 51:
		p.Type = "block_entity_data"
	case 54:
		p.Type = "ominous_bottle_amplifier"
	case 59:
		p.Type = "firework_explosion"
	case 61:
		p.Type = "profile"
	case 75:
		p.Type = "wolf/collar"
	case 78:
		p.Type = "parrot/variant"
	case 30:
		p.Type = "glider"
	case 32:
		p.Type = "death_protection"
	case 55:
		p.Type = "jukebox_playable"
	case 67:
		p.Type = "block_state"
	case 80:
		p.Type = "tropical_fish/base_color"
	case 87:
		p.Type = "frog/variant"
	case 91:
		p.Type = "axolotl/variant"
	case 93:
		p.Type = "cat/collar"
	case 13:
		p.Type = "attribute_modifiers"
	case 33:
		p.Type = "blocks_attacks"
	case 68:
		p.Type = "bees"
	case 74:
		p.Type = "wolf/sound_variant"
	case 84:
		p.Type = "pig/variant"
	case 88:
		p.Type = "horse/variant"
	case 94:
		p.Type = "sheep/color"
	case 2:
		p.Type = "max_damage"
	case 14:
		p.Type = "custom_model_data"
	case 42:
		p.Type = "bundle_contents"
	case 62:
		p.Type = "note_block_sound"
	case 70:
		p.Type = "container_loot"
	case 95:
		p.Type = "shulker/color"
	case 4:
		p.Type = "unbreakable"
	case 20:
		p.Type = "food"
	case 22:
		p.Type = "use_remainder"
	case 29:
		p.Type = "repairable"
	case 36:
		p.Type = "map_color"
	case 43:
		p.Type = "potion_contents"
	case 45:
		p.Type = "writable_book_content"
	case 9:
		p.Type = "rarity"
	case 16:
		p.Type = "repair_cost"
	case 21:
		p.Type = "consumable"
	case 63:
		p.Type = "banner_patterns"
	case 65:
		p.Type = "pot_decorations"
	case 83:
		p.Type = "rabbit/variant"
	case 92:
		p.Type = "cat/variant"
	case 1:
		p.Type = "max_stack_size"
	case 10:
		p.Type = "enchantments"
	case 44:
		p.Type = "suspicious_stew_effects"
	case 18:
		p.Type = "enchantment_glint_override"
	case 48:
		p.Type = "debug_stick_state"
	case 69:
		p.Type = "lock"
	case 77:
		p.Type = "salmon/size"
	case 79:
		p.Type = "tropical_fish/pattern"
	case 81:
		p.Type = "tropical_fish/pattern_color"
	case 89:
		p.Type = "painting/variant"
	case 11:
		p.Type = "can_place_on"
	case 31:
		p.Type = "tooltip_style"
	case 50:
		p.Type = "bucket_entity_data"
	case 53:
		p.Type = "provides_trim_material"
	case 57:
		p.Type = "recipes"
	case 17:
		p.Type = "creative_slot_lock"
	case 27:
		p.Type = "enchantable"
	case 39:
		p.Type = "map_post_processing"
	case 49:
		p.Type = "entity_data"
	case 60:
		p.Type = "fireworks"
	case 82:
		p.Type = "mooshroom/variant"
	case 8:
		p.Type = "lore"
	case 40:
		p.Type = "potion_duration_scale"
	case 73:
		p.Type = "wolf/variant"
	case 85:
		p.Type = "cow/variant"
	case 28:
		p.Type = "equippable"
	case 64:
		p.Type = "base_color"
	case 71:
		p.Type = "break_sound"
	case 90:
		p.Type = "llama/variant"
	case 0:
		p.Type = "custom_data"
	case 3:
		p.Type = "damage"
	case 24:
		p.Type = "damage_resistant"
	case 26:
		p.Type = "weapon"
	case 34:
		p.Type = "stored_enchantments"
	case 38:
		p.Type = "map_decorations"
	case 41:
		p.Type = "charged_projectiles"
	case 58:
		p.Type = "lodestone_tracker"
	case 6:
		p.Type = "item_name"
	case 12:
		p.Type = "can_break"
	case 19:
		p.Type = "intangible_projectile"
	case 25:
		p.Type = "tool"
	case 35:
		p.Type = "dyed_color"
	case 47:
		p.Type = "trim"
	default:
		return n, fmt.Errorf("unknown mapper value %d for Type", mapperVal)
	}

	return n, nil
}

// WriteTo writes the data to the writer.
func (p SetSlotItemRemoveComponentsEntry) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	switch p.Type {
	case "provides_banner_patterns":
		temp, err = pk.VarInt(56).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "fox/variant":
		temp, err = pk.VarInt(76).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "custom_name":
		temp, err = pk.VarInt(5).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "item_model":
		temp, err = pk.VarInt(7).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "tooltip_display":
		temp, err = pk.VarInt(15).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "map_id":
		temp, err = pk.VarInt(37).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "instrument":
		temp, err = pk.VarInt(52).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "container":
		temp, err = pk.VarInt(66).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "villager/variant":
		temp, err = pk.VarInt(72).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "chicken/variant":
		temp, err = pk.VarInt(86).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "use_cooldown":
		temp, err = pk.VarInt(23).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "written_book_content":
		temp, err = pk.VarInt(46).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "block_entity_data":
		temp, err = pk.VarInt(51).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "ominous_bottle_amplifier":
		temp, err = pk.VarInt(54).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "firework_explosion":
		temp, err = pk.VarInt(59).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "profile":
		temp, err = pk.VarInt(61).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "wolf/collar":
		temp, err = pk.VarInt(75).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "parrot/variant":
		temp, err = pk.VarInt(78).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "glider":
		temp, err = pk.VarInt(30).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "death_protection":
		temp, err = pk.VarInt(32).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "jukebox_playable":
		temp, err = pk.VarInt(55).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "block_state":
		temp, err = pk.VarInt(67).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "tropical_fish/base_color":
		temp, err = pk.VarInt(80).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "frog/variant":
		temp, err = pk.VarInt(87).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "axolotl/variant":
		temp, err = pk.VarInt(91).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "cat/collar":
		temp, err = pk.VarInt(93).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "attribute_modifiers":
		temp, err = pk.VarInt(13).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "blocks_attacks":
		temp, err = pk.VarInt(33).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "bees":
		temp, err = pk.VarInt(68).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "wolf/sound_variant":
		temp, err = pk.VarInt(74).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "pig/variant":
		temp, err = pk.VarInt(84).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "horse/variant":
		temp, err = pk.VarInt(88).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "sheep/color":
		temp, err = pk.VarInt(94).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "max_damage":
		temp, err = pk.VarInt(2).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "custom_model_data":
		temp, err = pk.VarInt(14).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "bundle_contents":
		temp, err = pk.VarInt(42).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "note_block_sound":
		temp, err = pk.VarInt(62).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "container_loot":
		temp, err = pk.VarInt(70).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "shulker/color":
		temp, err = pk.VarInt(95).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "unbreakable":
		temp, err = pk.VarInt(4).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "food":
		temp, err = pk.VarInt(20).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "use_remainder":
		temp, err = pk.VarInt(22).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "repairable":
		temp, err = pk.VarInt(29).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "map_color":
		temp, err = pk.VarInt(36).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "potion_contents":
		temp, err = pk.VarInt(43).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "writable_book_content":
		temp, err = pk.VarInt(45).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "rarity":
		temp, err = pk.VarInt(9).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "repair_cost":
		temp, err = pk.VarInt(16).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "consumable":
		temp, err = pk.VarInt(21).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "banner_patterns":
		temp, err = pk.VarInt(63).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "pot_decorations":
		temp, err = pk.VarInt(65).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "rabbit/variant":
		temp, err = pk.VarInt(83).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "cat/variant":
		temp, err = pk.VarInt(92).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "max_stack_size":
		temp, err = pk.VarInt(1).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "enchantments":
		temp, err = pk.VarInt(10).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "suspicious_stew_effects":
		temp, err = pk.VarInt(44).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "enchantment_glint_override":
		temp, err = pk.VarInt(18).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "debug_stick_state":
		temp, err = pk.VarInt(48).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "lock":
		temp, err = pk.VarInt(69).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "salmon/size":
		temp, err = pk.VarInt(77).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "tropical_fish/pattern":
		temp, err = pk.VarInt(79).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "tropical_fish/pattern_color":
		temp, err = pk.VarInt(81).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "painting/variant":
		temp, err = pk.VarInt(89).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "can_place_on":
		temp, err = pk.VarInt(11).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "tooltip_style":
		temp, err = pk.VarInt(31).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "bucket_entity_data":
		temp, err = pk.VarInt(50).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "provides_trim_material":
		temp, err = pk.VarInt(53).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "recipes":
		temp, err = pk.VarInt(57).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "creative_slot_lock":
		temp, err = pk.VarInt(17).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "enchantable":
		temp, err = pk.VarInt(27).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "map_post_processing":
		temp, err = pk.VarInt(39).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "entity_data":
		temp, err = pk.VarInt(49).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "fireworks":
		temp, err = pk.VarInt(60).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "mooshroom/variant":
		temp, err = pk.VarInt(82).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "lore":
		temp, err = pk.VarInt(8).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "potion_duration_scale":
		temp, err = pk.VarInt(40).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "wolf/variant":
		temp, err = pk.VarInt(73).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "cow/variant":
		temp, err = pk.VarInt(85).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "equippable":
		temp, err = pk.VarInt(28).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "base_color":
		temp, err = pk.VarInt(64).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "break_sound":
		temp, err = pk.VarInt(71).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "llama/variant":
		temp, err = pk.VarInt(90).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "custom_data":
		temp, err = pk.VarInt(0).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "damage":
		temp, err = pk.VarInt(3).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "damage_resistant":
		temp, err = pk.VarInt(24).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "weapon":
		temp, err = pk.VarInt(26).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "stored_enchantments":
		temp, err = pk.VarInt(34).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "map_decorations":
		temp, err = pk.VarInt(38).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "charged_projectiles":
		temp, err = pk.VarInt(41).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "lodestone_tracker":
		temp, err = pk.VarInt(58).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "item_name":
		temp, err = pk.VarInt(6).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "can_break":
		temp, err = pk.VarInt(12).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "intangible_projectile":
		temp, err = pk.VarInt(19).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "tool":
		temp, err = pk.VarInt(25).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "dyed_color":
		temp, err = pk.VarInt(35).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	case "trim":
		temp, err = pk.VarInt(47).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	default:
		return n, fmt.Errorf("unknown Type value %v", p.Type)
	}

	return n, nil
}

// SetSlotItem is a sub-structure used in the packet.
type SetSlotItem struct {
	ItemCount             int32 `mc:"VarInt"`
	ItemId                int32 `mc:"VarInt"`
	AddedComponentCount   int32 `mc:"VarInt"`
	RemovedComponentCount int32 `mc:"VarInt"`
	Components            []SetSlotItemTemp
	RemoveComponents      []SetSlotItemRemoveComponentsEntry
}

// ReadFrom reads the data from the reader.
func (p *SetSlotItem) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	var itemCount pk.VarInt
	temp, err = itemCount.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.ItemCount = int32(itemCount)

	if p.ItemCount != 0 {
		var itemId pk.VarInt
		temp, err = itemId.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.ItemId = int32(itemId)
	}

	if p.ItemCount != 0 {
		var addedComponentCount pk.VarInt
		temp, err = addedComponentCount.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.AddedComponentCount = int32(addedComponentCount)
	}

	if p.ItemCount != 0 {
		var removedComponentCount pk.VarInt
		temp, err = removedComponentCount.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.RemovedComponentCount = int32(removedComponentCount)
	}

	if p.ItemCount != 0 {
		var componentsCount pk.VarInt
		temp, err = componentsCount.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.Components = make([]SetSlotItemTemp, componentsCount)
		for i := 0; i < int(componentsCount); i++ {
			temp, err = p.Components[i].ReadFrom(r)
			n += temp
			if err != nil {
				return n, err
			}
		}
	}

	if p.ItemCount != 0 {
		var removeComponentsCount pk.VarInt
		temp, err = removeComponentsCount.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
		p.RemoveComponents = make([]SetSlotItemRemoveComponentsEntry, removeComponentsCount)
		for i := 0; i < int(removeComponentsCount); i++ {
			temp, err = p.RemoveComponents[i].ReadFrom(r)
			n += temp
			if err != nil {
				return n, err
			}
		}
	}

	return n, nil
}

// WriteTo writes the data to the writer.
func (p SetSlotItem) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	temp, err = pk.VarInt(p.ItemCount).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	if p.ItemCount != 0 {
		temp, err = pk.VarInt(p.ItemId).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	}

	if p.ItemCount != 0 {
		temp, err = pk.VarInt(p.AddedComponentCount).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	}

	if p.ItemCount != 0 {
		temp, err = pk.VarInt(p.RemovedComponentCount).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	}

	if p.ItemCount != 0 {
		temp, err = pk.VarInt(len(p.Components)).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
		for i := range p.Components {
			temp, err = p.Components[i].WriteTo(w)
			n += temp
			if err != nil {
				return n, err
			}
		}
	}

	if p.ItemCount != 0 {
		temp, err = pk.VarInt(len(p.RemoveComponents)).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
		for i := range p.RemoveComponents {
			temp, err = p.RemoveComponents[i].WriteTo(w)
			n += temp
			if err != nil {
				return n, err
			}
		}
	}

	return n, nil
}

// SetSlot represents the Clientbound SetSlot packet.

type SetSlot struct {
	WindowId int32 `mc:"VarInt"`
	StateId  int32 `mc:"VarInt"`
	Slot     int16
	Item     SetSlotItem
}

// PacketID returns the packet ID for this packet.
func (*SetSlot) PacketID() packetid.ClientboundPacketID {
	return packetid.ClientboundSetSlot
}

// ReadFrom reads the packet data from the reader.
func (p *SetSlot) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	var windowId pk.VarInt
	temp, err = windowId.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.WindowId = int32(windowId)

	var stateId pk.VarInt
	temp, err = stateId.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.StateId = int32(stateId)

	temp, err = (*pk.Short)(&p.Slot).ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = p.Item.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}

	return n, nil
}

// WriteTo writes the packet data to the writer.
func (p SetSlot) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	temp, err = pk.VarInt(p.WindowId).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.VarInt(p.StateId).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.Short(p.Slot).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = p.Item.WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	return n, nil
}

func init() {
	registerPacket(packetid.ClientboundSetSlot, func() ClientboundPacket {
		return &SetSlot{}
	})
}
