// Code generated by enhanced-generator v2 from protocol.json; DO NOT EDIT manually.
// To regenerate: go run main_v2.go -protocol <path> -output <dir> -direction client

package client

import (
	pk "git.konjactw.dev/falloutBot/go-mc/net/packet"
	"git.konjactw.dev/patyhank/minego/pkg/protocol/packetid"
	"git.konjactw.dev/patyhank/minego/pkg/protocol/slot"
	"io"
)

// TradeListTradesEntryInputItem1 is a sub-structure used in the packet.
type TradeListTradesEntryInputItem1 struct {
	ItemId     int32 `mc:"VarInt"`
	ItemCount  int32 `mc:"VarInt"`
	Components interface{}
}

// ReadFrom reads the data from the reader.
func (p *TradeListTradesEntryInputItem1) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	var itemId pk.VarInt
	temp, err = itemId.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.ItemId = int32(itemId)

	var itemCount pk.VarInt
	temp, err = itemCount.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.ItemCount = int32(itemCount)

	// TODO: Read Components (unsupported type ExactComponentMatcher)

	return n, nil
}

// WriteTo writes the data to the writer.
func (p TradeListTradesEntryInputItem1) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	temp, err = pk.VarInt(p.ItemId).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.VarInt(p.ItemCount).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	// TODO: Write Components (unsupported type ExactComponentMatcher)

	return n, nil
}

// TradeListTradesEntryInputItem2 is a sub-structure used in the packet.
type TradeListTradesEntryInputItem2 struct {
	ItemId     int32 `mc:"VarInt"`
	ItemCount  int32 `mc:"VarInt"`
	Components interface{}
}

// ReadFrom reads the data from the reader.
func (p *TradeListTradesEntryInputItem2) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	var itemId pk.VarInt
	temp, err = itemId.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.ItemId = int32(itemId)

	var itemCount pk.VarInt
	temp, err = itemCount.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.ItemCount = int32(itemCount)

	// TODO: Read Components (unsupported type ExactComponentMatcher)

	return n, nil
}

// WriteTo writes the data to the writer.
func (p TradeListTradesEntryInputItem2) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	temp, err = pk.VarInt(p.ItemId).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.VarInt(p.ItemCount).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	// TODO: Write Components (unsupported type ExactComponentMatcher)

	return n, nil
}

// TradeListTradesEntry is a sub-structure used in the packet.
type TradeListTradesEntry struct {
	InputItem1         TradeListTradesEntryInputItem1
	OutputItem         slot.Slot
	InputItem2         *TradeListTradesEntryInputItem2
	TradeDisabled      bool
	NbTradeUses        int32
	MaximumNbTradeUses int32
	Xp                 int32
	SpecialPrice       int32
	PriceMultiplier    float32
	Demand             int32
}

// ReadFrom reads the data from the reader.
func (p *TradeListTradesEntry) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	temp, err = p.InputItem1.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = (*slot.Slot)(&p.OutputItem).ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}

	var hasInputItem2 pk.Boolean
	temp, err = hasInputItem2.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	if hasInputItem2 {
		p.InputItem2 = &TradeListTradesEntryInputItem2{}
		temp, err = p.InputItem2.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
	}

	var tradeDisabled pk.Boolean
	temp, err = tradeDisabled.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.TradeDisabled = bool(tradeDisabled)

	temp, err = (*pk.Int)(&p.NbTradeUses).ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = (*pk.Int)(&p.MaximumNbTradeUses).ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = (*pk.Int)(&p.Xp).ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = (*pk.Int)(&p.SpecialPrice).ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = (*pk.Float)(&p.PriceMultiplier).ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = (*pk.Int)(&p.Demand).ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}

	return n, nil
}

// WriteTo writes the data to the writer.
func (p TradeListTradesEntry) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	temp, err = p.InputItem1.WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = p.OutputItem.WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	if p.InputItem2 != nil {
		temp, err = pk.Boolean(true).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
		temp, err = p.InputItem2.WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	} else {
		temp, err = pk.Boolean(false).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	}

	temp, err = pk.Boolean(p.TradeDisabled).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.Int(p.NbTradeUses).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.Int(p.MaximumNbTradeUses).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.Int(p.Xp).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.Int(p.SpecialPrice).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.Float(p.PriceMultiplier).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.Int(p.Demand).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	return n, nil
}

// TradeList represents the Clientbound TradeList packet.

type TradeList struct {
	WindowId          int8
	Trades            []TradeListTradesEntry
	VillagerLevel     int32 `mc:"VarInt"`
	Experience        int32 `mc:"VarInt"`
	IsRegularVillager bool
	CanRestock        bool
}

// PacketID returns the packet ID for this packet.
func (*TradeList) PacketID() packetid.ClientboundPacketID {
	return packetid.ClientboundTradeList
}

// ReadFrom reads the packet data from the reader.
func (p *TradeList) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	// TODO: Read WindowId (ContainerID)

	var tradesCount pk.VarInt
	temp, err = tradesCount.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.Trades = make([]TradeListTradesEntry, tradesCount)
	for i := 0; i < int(tradesCount); i++ {
		temp, err = p.Trades[i].ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
	}

	var villagerLevel pk.VarInt
	temp, err = villagerLevel.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.VillagerLevel = int32(villagerLevel)

	var experience pk.VarInt
	temp, err = experience.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.Experience = int32(experience)

	var isRegularVillager pk.Boolean
	temp, err = isRegularVillager.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.IsRegularVillager = bool(isRegularVillager)

	var canRestock pk.Boolean
	temp, err = canRestock.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.CanRestock = bool(canRestock)

	return n, nil
}

// WriteTo writes the packet data to the writer.
func (p TradeList) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	// TODO: Write WindowId (ContainerID)

	temp, err = pk.VarInt(len(p.Trades)).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}
	for i := range p.Trades {
		temp, err = p.Trades[i].WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	}

	temp, err = pk.VarInt(p.VillagerLevel).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.VarInt(p.Experience).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.Boolean(p.IsRegularVillager).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.Boolean(p.CanRestock).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	return n, nil
}

func init() {
	registerPacket(packetid.ClientboundTradeList, func() ClientboundPacket {
		return &TradeList{}
	})
}
