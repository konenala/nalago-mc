//go:build ignore
// +build ignore

// Code generated by enhanced-generator v2 from protocol.json; DO NOT EDIT manually.
// To regenerate: go run main_v2.go -protocol <path> -output <dir> -direction server

package server

import (
	pk "git.konjactw.dev/falloutBot/go-mc/net/packet"
	"git.konjactw.dev/patyhank/minego/pkg/protocol/packetid"
	"io"
)

// WindowClickChangedSlotsEntryTempComponentsEntry is a sub-structure used in the packet.
type WindowClickChangedSlotsEntryTempComponentsEntry struct {
	// TODO: Implement mapper type
	Type interface{}
	Hash int32
}

// ReadFrom reads the data from the reader.
func (p *WindowClickChangedSlotsEntryTempComponentsEntry) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	// TODO: Read Type

	temp, err = (*pk.Int)(&p.Hash).ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}

	return n, nil
}

// WriteTo writes the data to the writer.
func (p WindowClickChangedSlotsEntryTempComponentsEntry) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	// TODO: Write Type

	temp, err = pk.Int(p.Hash).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	return n, nil
}

// WindowClickChangedSlotsEntryTempRemoveComponentsEntry is a sub-structure used in the packet.
type WindowClickChangedSlotsEntryTempRemoveComponentsEntry struct {
	// TODO: Implement mapper type
	Type interface{}
}

// ReadFrom reads the data from the reader.
func (p *WindowClickChangedSlotsEntryTempRemoveComponentsEntry) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	// TODO: Read Type

	return n, nil
}

// WriteTo writes the data to the writer.
func (p WindowClickChangedSlotsEntryTempRemoveComponentsEntry) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	// TODO: Write Type

	return n, nil
}

// WindowClickChangedSlotsEntryTemp is a sub-structure used in the packet.
type WindowClickChangedSlotsEntryTemp struct {
	ItemId           int32 `mc:"VarInt"`
	ItemCount        int32 `mc:"VarInt"`
	Components       []WindowClickChangedSlotsEntryTempComponentsEntry
	RemoveComponents []WindowClickChangedSlotsEntryTempRemoveComponentsEntry
}

// ReadFrom reads the data from the reader.
func (p *WindowClickChangedSlotsEntryTemp) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	var itemId pk.VarInt
	temp, err = itemId.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.ItemId = int32(itemId)

	var itemCount pk.VarInt
	temp, err = itemCount.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.ItemCount = int32(itemCount)

	var componentsCount pk.VarInt
	temp, err = componentsCount.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.Components = make([]WindowClickChangedSlotsEntryTempComponentsEntry, componentsCount)
	for i := 0; i < int(componentsCount); i++ {
		temp, err = p.Components[i].ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
	}

	var removeComponentsCount pk.VarInt
	temp, err = removeComponentsCount.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.RemoveComponents = make([]WindowClickChangedSlotsEntryTempRemoveComponentsEntry, removeComponentsCount)
	for i := 0; i < int(removeComponentsCount); i++ {
		temp, err = p.RemoveComponents[i].ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
	}

	return n, nil
}

// WriteTo writes the data to the writer.
func (p WindowClickChangedSlotsEntryTemp) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	temp, err = pk.VarInt(p.ItemId).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.VarInt(p.ItemCount).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.VarInt(len(p.Components)).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}
	for i := range p.Components {
		temp, err = p.Components[i].WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	}

	temp, err = pk.VarInt(len(p.RemoveComponents)).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}
	for i := range p.RemoveComponents {
		temp, err = p.RemoveComponents[i].WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	}

	return n, nil
}

// WindowClickChangedSlotsEntry is a sub-structure used in the packet.
type WindowClickChangedSlotsEntry struct {
	Location int16
	Item     *WindowClickChangedSlotsEntryTemp
}

// ReadFrom reads the data from the reader.
func (p *WindowClickChangedSlotsEntry) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	temp, err = (*pk.Short)(&p.Location).ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}

	var hasItem pk.Boolean
	temp, err = hasItem.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	if hasItem {
		p.Item = &WindowClickChangedSlotsEntryTemp{}
		temp, err = p.Item.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
	}

	return n, nil
}

// WriteTo writes the data to the writer.
func (p WindowClickChangedSlotsEntry) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	temp, err = pk.Short(p.Location).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	if p.Item != nil {
		temp, err = pk.Boolean(true).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
		temp, err = p.Item.WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	} else {
		temp, err = pk.Boolean(false).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	}

	return n, nil
}

// WindowClickTempComponentsEntry is a sub-structure used in the packet.
type WindowClickTempComponentsEntry struct {
	// TODO: Implement mapper type
	Type interface{}
	Hash int32
}

// ReadFrom reads the data from the reader.
func (p *WindowClickTempComponentsEntry) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	// TODO: Read Type

	temp, err = (*pk.Int)(&p.Hash).ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}

	return n, nil
}

// WriteTo writes the data to the writer.
func (p WindowClickTempComponentsEntry) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	// TODO: Write Type

	temp, err = pk.Int(p.Hash).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	return n, nil
}

// WindowClickTempRemoveComponentsEntry is a sub-structure used in the packet.
type WindowClickTempRemoveComponentsEntry struct {
	// TODO: Implement mapper type
	Type interface{}
}

// ReadFrom reads the data from the reader.
func (p *WindowClickTempRemoveComponentsEntry) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	// TODO: Read Type

	return n, nil
}

// WriteTo writes the data to the writer.
func (p WindowClickTempRemoveComponentsEntry) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	// TODO: Write Type

	return n, nil
}

// WindowClickTemp is a sub-structure used in the packet.
type WindowClickTemp struct {
	ItemId           int32 `mc:"VarInt"`
	ItemCount        int32 `mc:"VarInt"`
	Components       []WindowClickTempComponentsEntry
	RemoveComponents []WindowClickTempRemoveComponentsEntry
}

// ReadFrom reads the data from the reader.
func (p *WindowClickTemp) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	var itemId pk.VarInt
	temp, err = itemId.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.ItemId = int32(itemId)

	var itemCount pk.VarInt
	temp, err = itemCount.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.ItemCount = int32(itemCount)

	var componentsCount pk.VarInt
	temp, err = componentsCount.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.Components = make([]WindowClickTempComponentsEntry, componentsCount)
	for i := 0; i < int(componentsCount); i++ {
		temp, err = p.Components[i].ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
	}

	var removeComponentsCount pk.VarInt
	temp, err = removeComponentsCount.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.RemoveComponents = make([]WindowClickTempRemoveComponentsEntry, removeComponentsCount)
	for i := 0; i < int(removeComponentsCount); i++ {
		temp, err = p.RemoveComponents[i].ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
	}

	return n, nil
}

// WriteTo writes the data to the writer.
func (p WindowClickTemp) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	temp, err = pk.VarInt(p.ItemId).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.VarInt(p.ItemCount).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.VarInt(len(p.Components)).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}
	for i := range p.Components {
		temp, err = p.Components[i].WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	}

	temp, err = pk.VarInt(len(p.RemoveComponents)).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}
	for i := range p.RemoveComponents {
		temp, err = p.RemoveComponents[i].WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	}

	return n, nil
}

// WindowClick represents the Serverbound WindowClick packet.

type WindowClick struct {
	WindowId     int32 `mc:"VarInt"`
	StateId      int32 `mc:"VarInt"`
	Slot         int16
	MouseButton  int8
	Mode         int32 `mc:"VarInt"`
	ChangedSlots []WindowClickChangedSlotsEntry
	CursorItem   *WindowClickTemp
}

// PacketID returns the packet ID for this packet.
func (*WindowClick) PacketID() packetid.ServerboundPacketID {
	return packetid.ServerboundWindowClick
}

// ReadFrom reads the packet data from the reader.
func (p *WindowClick) ReadFrom(r io.Reader) (n int64, err error) {
	var temp int64
	_ = temp

	var windowId pk.VarInt
	temp, err = windowId.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.WindowId = int32(windowId)

	var stateId pk.VarInt
	temp, err = stateId.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.StateId = int32(stateId)

	temp, err = (*pk.Short)(&p.Slot).ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}

	var mouseButton int8
	temp, err = (*pk.Byte)(&mouseButton).ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.MouseButton = mouseButton

	var mode pk.VarInt
	temp, err = mode.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.Mode = int32(mode)

	var changedSlotsCount pk.VarInt
	temp, err = changedSlotsCount.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	p.ChangedSlots = make([]WindowClickChangedSlotsEntry, changedSlotsCount)
	for i := 0; i < int(changedSlotsCount); i++ {
		temp, err = p.ChangedSlots[i].ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
	}

	var hasCursorItem pk.Boolean
	temp, err = hasCursorItem.ReadFrom(r)
	n += temp
	if err != nil {
		return n, err
	}
	if hasCursorItem {
		p.CursorItem = &WindowClickTemp{}
		temp, err = p.CursorItem.ReadFrom(r)
		n += temp
		if err != nil {
			return n, err
		}
	}

	return n, nil
}

// WriteTo writes the packet data to the writer.
func (p WindowClick) WriteTo(w io.Writer) (n int64, err error) {
	var temp int64
	_ = temp

	temp, err = pk.VarInt(p.WindowId).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.VarInt(p.StateId).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.Short(p.Slot).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.Byte(p.MouseButton).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.VarInt(p.Mode).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}

	temp, err = pk.VarInt(len(p.ChangedSlots)).WriteTo(w)
	n += temp
	if err != nil {
		return n, err
	}
	for i := range p.ChangedSlots {
		temp, err = p.ChangedSlots[i].WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	}

	if p.CursorItem != nil {
		temp, err = pk.Boolean(true).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
		temp, err = p.CursorItem.WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	} else {
		temp, err = pk.Boolean(false).WriteTo(w)
		n += temp
		if err != nil {
			return n, err
		}
	}

	return n, nil
}

func init() {
	registerPacket(packetid.ServerboundWindowClick, func() ServerboundPacket {
		return &WindowClick{}
	})
}
